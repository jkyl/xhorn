<HTML>
<HEAD>
<TITLE>Notes on overhead</TITLE>
</HEAD>
<BODY TEXT="#000000"  BGCOLOR="#F0F0F0">

<H2>April 16, 2016 - Notes on integration overhead</H2>

<p>
<hr>
<p>
While we can still acheive continuous integration with some overhead time, if the overhead exceeds the length of an accumulation, we end up skipping it over. Here I discuss the dominant sources of overhead and why it's a bad idea to set the accumulation length less than a few tenths of a second. 
<p>
Run the following in IPython:
<UL><xmp>In [1]: from spec import Spec
In [2]: s = Spec(acc_len = 0.001)
...
In [3]: %timeit s.snap_spec()
10 loops, best of 3: 122 ms per loop</xmp></UL>
<p>
Note that the time cost of snapping the power spectrum with an accumulation length of 1ms is overhead-dominated. Even if the board took the entire 1ms to yield an integration, we'd be stuck waiting around another 120ms for the next one. It's unlikely that the source of this overhead is anything we can control -- the ancillary code in <code>snap_spec()</code> contributes only a few microseconds. The largest factor is probably upload/download speed. 
<p>
Another source of overhead comes from querying the motor's position, which we'll probably do after each accumulation in a loop. 
<UL><xmp>In [4]: from motor import Motor
In [5]: m = Motor()
In [6]: %timeit m.position()
10 loops, best of 3: 21.3 ms per loop
</xmp></UL>
<p>
Unless we decide to query the motor position in parallel with the spectrum accumulation, this is another cost we'll have to deal with. For the time being it's probably a good idea to keep the accumulation length above half a second. 
