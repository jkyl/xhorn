from numpy import *
from matplotlib.pyplot import *
from xhorn import time_sync as ts
from xhorn import in_out as io
from xhorn import reduc_spec as rs

class data:
    def __init__(self, *args, **kwargs):
        '''
        A class containing reduced data generated by reduce(). 
        
        Args can be either time tuples (including None), .npz filepaths,
        .h5 filepaths, or standalone reduc_spec.data objects. 
        '''
        za0_ind = max(kwargs.get('za0_ind'), 0)
        try:
            try:
                if len(args) < 1:
                    raise TypeError
                self._set_attrs(reduce(args[0], za0_ind))
            except AttributeError:
                if type(args[0]) is str:
                    if '.np' in args[0]:
                        self._load(args[0])
                    elif any(('.h5' in arg for arg in args)):
                        self._set_attrs(reduce(rs.data(*args), za0_ind))
                elif type(args[0]) is tuple:
                    self._set_attrs(reduce(rs.data(*args, **kwargs), za0_ind))
                else:
                    raise TypeError
        except TypeError:
            raise TypeError, '*args must be in of the following forms: '+\
                'one reduc_spec.data object, two time tuples, '+\
                'any number of .h5 filepaths, or one .np(z) filepath.'
        
    def _set_attrs(self, d):
        '''
        '''
        for k, v in d.items():
            setattr(self, k, v)

    def _load(self, fname='../reduc_data/test.npz'):
        '''
        '''
        with load(fname) as f:
            self._set_attrs({k: v for k, v in f.items()})
        
    def save(self, fname='../reduc_data/test.npz'):
        '''
        '''
        savez_compressed(fname, **self.__dict__)

    
def reduce(d, za0_ind=0):
    '''
    '''
    scan_inds = d.getscanind()
    za = unique(d.za[scan_inds])
    am = d.za2am(za)
    mean_am = d.am[scan_inds].mean()
    za0 = za[za0_ind]
    am0 = am[za0_ind]
    containers = {}
    for i, za1 in enumerate(za):
        am1 = am[where(za==za1)]
        for k in range(d.nscan):
            za1_inds, za0_inds = (where((d.scan==k) & (d.za==za_))[0] for za_ in (za1, za0))
            za1_spec, za0_spec = (d.spec[za_inds].mean(0) for za_inds in (za1_inds, za0_inds))
            mean_spec = d.spec[d.getscanind(k)].mean(0) 
            numerator = za1_spec - mean_spec
            denominator = za0_spec - mean_spec
            ratio = numerator / denominator
            output = ['za1_spec', 'za0_spec', 'mean_spec', 'ratio']
            for o in output :
                if not o in containers:
                    containers[o] = zeros((d.nscan, d.nf, za.size))                 
                containers[o][k,:,i] = eval(o)
    expect = (am - mean_am) / (am0 - mean_am)
    n_per_scan = d.mjd.size / d.nscan
    times = vectorize(ts.mjd_to_iso)(d.mjd)[::n_per_scan]
    for i in ['am', 'mean_am', 'expect', 'times', 'za', 'za0_ind']:
        containers[i] = eval(i)
    return containers

def plot_ratio(ratio, expect, zas, d_za=1, za0_ind=0):
    '''
    Accepts an (n_chans, n_ZAs)-shaped array of reduced data, and 
    an (n_ZAs,)-shaped array of expectations, and plots them as 
    (n_ZAs) populations alongside the corresponding prediction. 
    '''
    colors = ['b', 'g', 'r', 'c', 'm']
    f = linspace(9.5, 11.7, 2048)
    ex = tile(expect, (2, 1))
    plus_am, minus_am = (tile(a, (2, 1)) - ex for a in ratio_err(zas, d_za, za0_ind))
    figure(1, figsize=(15, 8));clf()
    plot([],[], 'k', label='Expectation values')
    plot([], [], 'k.', label='Mean')
    plot([], [], 'gray', linewidth=10, label='$\sigma_{za}=\pm1^\circ$')
    for i in range(ratio.shape[2]):
        c = colors[i]
        mean_ = mu(ratio, 0)[:,i]
        err = sigma(ratio, 0)[:,i]
        fill_between(f, mean_ - err, mean_ + err,
                     facecolor=c, edgecolor=c, alpha=0.8)
        fill_between([f[0], f[-1]], ex[:,i] + plus_am[:,i], ex[:,i] + minus_am[:,i],
                     facecolor = 'gray', edgecolor='gray', alpha=.3)
        plot([],[],c,label = 'za={}$^\circ \pm 1\sigma$'.format(zas[i]), 
             linewidth=10)
        plot(f, mu(ratio, 0)[:, i], 'k.', ms=.8)
        plot([f[0], f[-1]], [expect[i], expect[i]], 'k')
    ylim(-1.5, 1.5)
    xlim(9.75, 11.7)
    xticks(arange(9.75, 11.75, .25), rotation=-90, ha='center')
    grid(True)
    legend(loc='upper left',prop={'size':11})
    title(r'$T_{{sky}}$ ratio, {} airmasses with 1 sigma error bands'.format(len(zas)))
    xlabel('Frequency (GHz)')
    ylabel(r'$R(f)$, $\theta_0={}^\circ$, average over {} scans'.format(zas[za0_ind], 
                                                                        ratio.shape[0]), size=16)
    tight_layout()

def waterfall_res(data, expect, times, dosave=False):
    '''
    Generates (n_ZA) images of the residuals of the reduced data
    wrt. their expectation over time. 
    '''
    close('all')
    zas = array([20., 32.6, 40.24, 45.74, 50.])
    for index, prediction in enumerate(expect):
        fig, ax1 = subplots(figsize=(10, 10))
        img = data[:, :, index].copy() - prediction
        imshow(img, vmin=-2, vmax=2)
        #colorbar()
        xticks(arange(2048)[::2048/22.], 
               [round(a, 2) for a in linspace(9.5, 11.7, 23)],
               rotation=-90, ha='center')
        xlabel('Frequency (GHz)')
        ylabel('Scan number')
        ax2 = ax1.twinx()
        yticks(arange(times.size)[::-50], 
               [t[6:-7] for t in times[::50]], 
               size='x-small', va='top', rotation=-45)
        ylabel('Time (UTC)')
        title(r'$T_{{sky}}$ ratio residuals, railed at $\pm2$, $\theta_z={}^\circ$'.format(zas[index]))
        tight_layout()
        if dosave:
            savefig('../reduc_data/fig_{}.png'.format(index))

def waterfall_spec(data, times, dosave=False):
    '''
    Generates (n_ZA) images of the residuals of the reduced data
    wrt. their expectation over time. 
    '''
    close('all')
    zas = array([20., 32.6, 40.24, 45.74, 50.])
    for index in range(data.shape[2]):
        fig, ax1 = subplots(figsize=(10, 10))
        img = data[:, :, index].copy()
        imshow(img, vmin=nanmin(data), vmax=nanmax(data))
        #colorbar()
        xticks(arange(2048)[::2048/22.], 
               [round(a, 2) for a in linspace(9.5, 11.7, 23)],
               rotation=-90, ha='center')
        xlabel('Frequency (GHz)')
        ylabel('Scan number')
        ax2 = ax1.twinx()
        yticks(arange(times.size)[::-50], 
               [t[6:-7] for t in times[::50]], 
               size='x-small', va='top', rotation=-45)
        ylabel('Time (UTC)')
        title(r'$\overline{{V^{{\ 2}}}}, \,\theta_z=\ {}^\circ$'.format(zas[index]))
        tight_layout()
        if dosave:
            savefig('../reduc_data/fig_{}.png'.format(index+5))

def sigma(data, axis):
    return nanstd(data.copy(), axis=axis)
    
def mu(data, axis, weights=None):
    if weights is None:
        weights = ones_like(data)
    return array(ma.average(data.copy(), axis=axis, weights=weights))

def ratio_err(za, d_za, za0_ind=0):
    '''
    Assumes the mean airmass is not affected by d_za, i.e. not a systematic offset.
    '''
    am = 1 / cos(pi * za / 180)
    plusmin = (1 / cos(pi * (za + d) / 180) for d in (d_za, -d_za))
    return ((a - am.mean()) / (a[za0_ind] - am.mean()) for a in plusmin)
